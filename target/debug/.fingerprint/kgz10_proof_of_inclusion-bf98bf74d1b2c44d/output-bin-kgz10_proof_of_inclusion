{"message":"no method named `scale` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":879,"byte_end":884,"line_start":18,"line_end":18,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"                poly = poly.scale(denom);","highlight_start":29,"highlight_end":34}],"label":"method not found in `DensePolynomial<<E as PairingEngine>::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `scale` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:18:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                poly = poly.scale(denom);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `DensePolynomial<<E as PairingEngine>::Fr>`\u001b[0m\n\n"}
{"message":"no method named `mul` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":919,"byte_end":922,"line_start":19,"line_end":19,"column_start":27,"column_end":30,"is_primary":true,"text":[{"text":"                l_i = l_i.mul(&poly);","highlight_start":27,"highlight_end":30}],"label":"method not found in `DensePolynomial<<E as PairingEngine>::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/rustc/1716932743a7b3705cbf0c34db0c4e070ed1930d/library/core/src/ops/arith.rs","byte_start":9066,"byte_end":9069,"line_start":333,"line_end":333,"column_start":8,"column_end":11,"is_primary":false,"text":[],"label":"the method is available for `DensePolynomial<<E as PairingEngine>::Fr>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait is implemented but not in scope; perhaps add a `use` for it:","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::ops::Mul;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `mul` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:19:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                l_i = l_i.mul(&poly);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `DensePolynomial<<E as PairingEngine>::Fr>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/1716932743a7b3705cbf0c34db0c4e070ed1930d/library/core/src/ops/arith.rs:333:8\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m |\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m = note: the method is available for `DensePolynomial<<E as PairingEngine>::Fr>` here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the following trait is implemented but not in scope; perhaps add a `use` for it:\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[38;5;10muse std::ops::Mul;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"no method named `scale` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":984,"byte_end":989,"line_start":22,"line_end":22,"column_start":30,"column_end":35,"is_primary":true,"text":[{"text":"        let scaled_l_i = l_i.scale(*y_i);","highlight_start":30,"highlight_end":35}],"label":"method not found in `DensePolynomial<<E as PairingEngine>::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `scale` found for struct `DensePolynomial<<E as PairingEngine>::Fr>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:22:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let scaled_l_i = l_i.scale(*y_i);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `DensePolynomial<<E as PairingEngine>::Fr>`\u001b[0m\n\n"}
{"message":"no method named `add` found for struct `DensePolynomial<_>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1043,"byte_end":1046,"line_start":23,"line_end":23,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"        interpolated_poly = interpolated_poly.add(&scaled_l_i);","highlight_start":47,"highlight_end":50}],"label":"method not found in `DensePolynomial<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/rustc/1716932743a7b3705cbf0c34db0c4e070ed1930d/library/core/src/ops/arith.rs","byte_start":2496,"byte_end":2499,"line_start":92,"line_end":92,"column_start":8,"column_end":11,"is_primary":false,"text":[],"label":"the method is available for `DensePolynomial<_>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait is implemented but not in scope; perhaps add a `use` for it:","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::ops::Add;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `add` found for struct `DensePolynomial<_>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:23:47\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        interpolated_poly = interpolated_poly.add(&scaled_l_i);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `DensePolynomial<_>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/1716932743a7b3705cbf0c34db0c4e070ed1930d/library/core/src/ops/arith.rs:92:8\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m |\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m = note: the method is available for `DensePolynomial<_>` here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the following trait is implemented but not in scope; perhaps add a `use` for it:\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[38;5;10muse std::ops::Add;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1983,"byte_end":1988,"line_start":50,"line_end":50,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"    let points: Vec<(E::Fr, E::Fr)> = vec![","highlight_start":22,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1983,"byte_end":1988,"line_start":50,"line_end":50,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"    let points: Vec<(E::Fr, E::Fr)> = vec![","highlight_start":22,"highlight_end":27}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:50:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let points: Vec<(E::Fr, E::Fr)> = vec![\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1990,"byte_end":1995,"line_start":50,"line_end":50,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"    let points: Vec<(E::Fr, E::Fr)> = vec![","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1990,"byte_end":1995,"line_start":50,"line_end":50,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"    let points: Vec<(E::Fr, E::Fr)> = vec![","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:50:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let points: Vec<(E::Fr, E::Fr)> = vec![\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2015,"byte_end":2020,"line_start":51,"line_end":51,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(1u32), E::Fr::from(35u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2015,"byte_end":2020,"line_start":51,"line_end":51,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(1u32), E::Fr::from(35u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:51:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(1u32), E::Fr::from(35u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2034,"byte_end":2039,"line_start":51,"line_end":51,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(1u32), E::Fr::from(35u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2034,"byte_end":2039,"line_start":51,"line_end":51,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(1u32), E::Fr::from(35u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:51:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(1u32), E::Fr::from(35u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2064,"byte_end":2069,"line_start":52,"line_end":52,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(2u32), E::Fr::from(92u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2064,"byte_end":2069,"line_start":52,"line_end":52,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(2u32), E::Fr::from(92u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:52:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(2u32), E::Fr::from(92u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2083,"byte_end":2088,"line_start":52,"line_end":52,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(2u32), E::Fr::from(92u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2083,"byte_end":2088,"line_start":52,"line_end":52,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(2u32), E::Fr::from(92u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:52:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(2u32), E::Fr::from(92u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2113,"byte_end":2118,"line_start":53,"line_end":53,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(3u32), E::Fr::from(111u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2113,"byte_end":2118,"line_start":53,"line_end":53,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"        (E::Fr::from(3u32), E::Fr::from(111u32)),","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:53:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(3u32), E::Fr::from(111u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait MyTrait {type X; }\n\nfn main() {\n    let foo: MyTrait::X;\n}\n```\n\nThe problem here is that we're attempting to take the type of X from MyTrait.\nUnfortunately, the type of X is not defined, because it's only made concrete in\nimplementations of the trait. A working version of this code might look like:\n\n```\ntrait MyTrait {type X; }\nstruct MyStruct;\n\nimpl MyTrait for MyStruct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <MyStruct as MyTrait>::X;\n}\n```\n\nThis syntax specifies that we want the X type from MyTrait, as made concrete in\nMyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\nmight implement two different traits with identically-named associated types.\nThis syntax allows disambiguation between the two.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2132,"byte_end":2137,"line_start":53,"line_end":53,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(3u32), E::Fr::from(111u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2132,"byte_end":2137,"line_start":53,"line_end":53,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        (E::Fr::from(3u32), E::Fr::from(111u32)),","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":"<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:53:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (E::Fr::from(3u32), E::Fr::from(111u32)),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: use the fully-qualified path: `<Bls12<ark_bls12_381::Parameters> as PairingEngine>::Fr`\u001b[0m\n\n"}
{"message":"aborting due to 12 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 12 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0223, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0223, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0223`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0223`.\u001b[0m\n"}
